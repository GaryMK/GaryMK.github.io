<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2023面经 | GaryMK</title><meta name="author" content="Gary MK,760246545@qq.com"><meta name="copyright" content="Gary MK"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="2023年校招面试过程中遇到的问题总结">
<meta property="og:type" content="article">
<meta property="og:title" content="2023面经">
<meta property="og:url" content="https://garymk.cn/2023/02/20/2023%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="GaryMK">
<meta property="og:description" content="2023年校招面试过程中遇到的问题总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg.png">
<meta property="article:published_time" content="2023-02-20T15:09:38.000Z">
<meta property="article:modified_time" content="2023-02-20T15:09:38.000Z">
<meta property="article:author" content="Gary MK">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://garymk.cn/2023/02/20/2023%E9%9D%A2%E7%BB%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="HEHvITU5ivSY_I-Y28VZuf7PUipzf-qPR7w9Uz1csDA"/><meta name="baidu-site-verification" content="codeva-f6yev5EHVP"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d3a6cf1a7d8ae018523cb3684a27486";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-5G6KHDXYS9"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5G6KHDXYS9');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":1000,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Gary MK","link":"链接: ","source":"来源: GaryMK","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2023面经',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-20 23:09:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="GaryMK" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wx.qlogo.cn/mmhead/Q3auHgzwzM40NV46MrdfnryFg6EIMAlt8uO7tfbtbs6XH9W2Z1Opfw/0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg.png')"><nav id="nav"><span id="blog-info"><a href="/" title="GaryMK"><span class="site-name">GaryMK</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2023面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-20T15:09:38.000Z" title="发表于 2023-02-20 23:09:38">2023-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-20T15:09:38.000Z" title="更新于 2023-02-20 23:09:38">2023-02-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="2023面经"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="waline-pageview-count" data-path="/2023/02/20/2023%E9%9D%A2%E7%BB%8F/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="2023校招面经"><a href="#2023校招面经" class="headerlink" title="2023校招面经"></a>2023校招面经</h1><h2 id="RecycleView-实现列表"><a href="#RecycleView-实现列表" class="headerlink" title="RecycleView  实现列表"></a>RecycleView  实现列表</h2><p>​		首先是在build.gradle里添加RecyclerView的依赖库，然后我们通过继承RecyclerView.Adapter,并在Adapter里定义一个内部类ViewHolder并在其中通过findViewById来获取列表每控件的实例，重写onCreateViewHolder,onBindViewHOlder以及getItemCount方法。onCreateViewHOlder用于创建ViewHolder实例，以及将列表所在布加载进来，监听事件的绑定；onBindViewHolder可以在子项滚动到屏幕内根据postion更新数据；getItemCount获取子项数目。</p>
<p>​		最后通过在Activity内的onCreate中初始化数据，获取RecyclerView实例并设置布局。最后设置适配器。</p>
<h2 id="RecycleView-实现多条目"><a href="#RecycleView-实现多条目" class="headerlink" title="RecycleView 实现多条目"></a>RecycleView 实现多条目</h2><p>​	在ViewHolder定义多个控件。</p>
<h2 id="HashMap，HashSet-和-HashTable"><a href="#HashMap，HashSet-和-HashTable" class="headerlink" title="HashMap，HashSet 和 HashTable"></a>HashMap，HashSet 和 HashTable</h2><p>实现上：</p>
<p>​	都实现了Map接口，并且都是Key-Value的形式。HashSet是集合形式，且不能重复。</p>
<p>源码上：</p>
<p><img src="https://garymk-1258635034.cos.ap-beijing.myqcloud.com/typora/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5em4xNDI1MDc3MTE5%2Csize_16%2Ccolor_FFFFFF%2Ct_70.png" alt="img"></p>
<p>​	HashMap是一种散列表,采用(数组 + 链表 + 红黑树)的存储结构;</p>
<p>​	HashTable是数组+链表；链地址法处理冲突。</p>
<p>​	HashSet底层是采用HashMap实现的，每次add添加的元素作为map的key，而Value固定为PRESENT，从而实现不能重复。</p>
<p><strong>在Jdk8引入树化，当元素个数达到64且链表的长度达到8时进行树化，当链表的长度小于6时反树化。<em>这样可以利用链表对内存的使用率以及红黑树的高效检索,是一种很有效率的数据结构。</em></strong></p>
<p>安全上：</p>
<p>HashMap不是线程安全的，HashTable通过synchronized实现线程安全，是同步的。</p>
<blockquote>
<p>负载因子（loadFactor）：<br>当我们第一次创建 HashMap 的时候，就会指定其容量（如果未明确指定，默认是 16），随着我们不断的向 HashMap 中 put 元素的时候，就有可能会超过其容量，那么就需要有一个扩容机制。</p>
<p>所谓扩容，就是扩大 HashMap 的容量,在向 HashMap 中添加元素过程中，如果 元素个数（size）超过临界值（threshold） 的时候，就会进行自动扩容（resize），并且，在扩容之后，还需要对 HashMap 中原有元素进行 rehash，即将原来桶中的元素重新分配到新的桶中。</p>
<p>在 HashMap 中，临界值（threshold） &#x3D; 负载因子（loadFactor） * 容量（capacity）。</p>
<p>loadFactor 是装载因子（负载因子），表示 HashMap 满的程度，默认值为 0.75f，也就是说默认情况下，当 HashMap 中元素个数达到了容量的 3&#x2F;4 的时候就会进行自动扩容。</p>
</blockquote>
<h2 id="Hash的初始Size"><a href="#Hash的初始Size" class="headerlink" title="Hash的初始Size"></a>Hash的初始Size</h2><p>HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。（为什么HashMap要是2的倍数扩容，原因是减小冲突）</p>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式</p>
<h1 id="Synchronized实现原理，泄漏"><a href="#Synchronized实现原理，泄漏" class="headerlink" title="Synchronized实现原理，泄漏"></a>Synchronized实现原理，泄漏</h1><p>​		synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized 翻译为中文的意思是同步，也称之为<strong>同步锁</strong>。<br>synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p>
<p>​		Synchronized的底层实现是完全依赖JVM虚拟机的,所以谈synchronized的底层实现，就不得不谈数据在JVM内存的存储：Java对象头，以及Monitor对象监视器。</p>
<blockquote>
<p>1.Synchronized是由虚拟机实现的一种互斥同步方式，当你查看被Synchronized修饰的程序块编译后的字节码时，会发现程序块被编译前后生成了monitorenter 和 monitorexit 两 个 字 节 码 指 令 ；</p>
<p>2.在虚拟机运行到monitorenter 时，先获取对象的锁，如果对象没有锁定，或者当前线程已经拥有这个对象的锁，则把锁+1；运行monitorexit时则将计时器-1，当计时器为0时，锁就会被释放；</p>
<p>3.如果对象获取失败了，那么当前的线程就要阻塞等待，直到对象锁被另一个线程释放为止；</p>
</blockquote>
<h2 id="锁泄漏-Lock-Leak）"><a href="#锁泄漏-Lock-Leak）" class="headerlink" title="锁泄漏(Lock Leak）"></a>锁泄漏(Lock Leak）</h2><p>锁泄漏是指一个线程获得某个锁以后，由于程序的错误、缺陷致使该锁一直没法被释放而导致其他线程一直无法获得该锁的现象。</p>
<p>内部锁synchronized不会造成锁泄漏(Lock Leak)，当临界区发生异常，JVM查找异常表，来保证monitorexit一定能够执行成功，锁一定会被释放。。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>​		JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><ul>
<li><blockquote>
<p>类加载系统：负责完成类的加载</p>
<p>运⾏时数据区：在运⾏Java程序的时候会产⽣的各种数据会保存在运⾏时数据区</p>
<p>执⾏引擎：执⾏具体的指令（代码）</p>
</blockquote>
</li>
</ul>
<h4 id="对象成为垃圾的判断依据"><a href="#对象成为垃圾的判断依据" class="headerlink" title="对象成为垃圾的判断依据"></a>对象成为垃圾的判断依据</h4><p>引⽤计数法,可达性分析算法</p>
<p> 当Java程序创建对象时，JVM会在堆内存中为对象分配内存。 当对象不再被使用时，它们就会成为垃圾。 如果不进行垃圾回收，这些垃圾对象将永远占用内存，并最终导致内存溢出。</p>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p>标记清除算法、复制算法、标记整理算法、分代回收法</p>
<h2 id="Android计算图片大小"><a href="#Android计算图片大小" class="headerlink" title="Android计算图片大小"></a>Android计算图片大小</h2><p>图片高度 * 图片宽度 * 一个像素占用的字节数</p>
<h2 id="Java的反射"><a href="#Java的反射" class="headerlink" title="Java的反射"></a>Java的反射</h2><p>​		反射的概述JAVA反射机制是在<strong>运行状态</strong>中，对于任意一个类，都能够知道这个类的<strong>所有属性和方法</strong>；对于任意一个对象，都能够<strong>调用</strong>它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。要想解剖一个类,必须先要获取到该类的</p>
<h3 id="获取类对应的字节码的对象"><a href="#获取类对应的字节码的对象" class="headerlink" title="获取类对应的字节码的对象"></a>获取类对应的字节码的对象</h3><p><strong>①</strong> 调用某个类的对象的getClass()方法，即：对象.getClass()；</p>
<p><strong>②</strong> 调用类的class属性类获取该类对应的Class对象，即：类名.class</p>
<p><strong>③</strong> 使用Class类中的forName()静态方法（最安全，性能最好）即：Class.forName(“类的全路径”)</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>android的sdk中，有一些用hide标记的方法，或者是private方法 属性，这些方法不能直接通过sdk的api调用，如果我们需要用到此功能，只能通过反射的机制来调用它。</p>
<p>发一些工具类的时候，例如网络数据，数据库数据和类之间的相互转化。使用反射机制可以直接创建对象，方便代码管理。</p>
<h2 id="手写单例"><a href="#手写单例" class="headerlink" title="手写单例"></a>手写单例</h2><p>​		类加载时就初始化实例，避免了多线程同步问题，天然线程安全。实例对象在第一次被调用的时候才真正构建的，而不是程序一启动就会自动构建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//懒汉式单例类.在第一次调用的时候实例化自己 </span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    private static Singleton single=null;</span><br><span class="line">    //静态工厂方法 </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">         if (single == null) &#123;  </span><br><span class="line">             single = new Singleton();</span><br><span class="line">         &#125;  </span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//饿汉式单例类.在类初始化时，已经自行实例化 </span><br><span class="line">public class Singleton1 &#123;</span><br><span class="line">    private Singleton1() &#123;&#125;</span><br><span class="line">    private static final Singleton1 single = new Singleton1();</span><br><span class="line">    //静态工厂方法 </span><br><span class="line">    public static Singleton1 getInstance() &#123;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四大组件是运行在主线程还是子线程"><a href="#四大组件是运行在主线程还是子线程" class="headerlink" title="四大组件是运行在主线程还是子线程"></a>四大组件是运行在主线程还是子线程</h2><p>安卓四大组件：Activity、Service、BroadcastReceiver和ContentProvider</p>
<p><strong>Activity组件</strong>的主要作用是展示一个界面并和用户交互，它扮演的是一种前台界面的角色、</p>
<p><strong>Service类</strong>似于其他应用程序的对象，运行在<strong>主线程</strong>中。这就意味着你如果在服务中进行耗时的操作，你需要开启一个子线程去处理这个操作，不然在服务中超过20秒未响应会发生ANR导致程序崩溃。IntentService的出现就是为了解决在服务中操作耗时任务的。</p>
<p>音乐软件被切换后，仍然能够播放音乐，浏览器软件被切换后，下载依然进行。</p>
<p><strong>BroadcastReceiver</strong>是允许应用接收来自各处的广播信息，而<strong>ContentProvider</strong>则是主要用于跨应用程序的数据共享，因此数据对象不同。具体应用到场景上，广播接收器主要是应用接收感知系统的信息与变化，如终端的息屏亮屏，有网没网、短信等信息，而内容提供器则是主要和不同应用之间交互共享数据，如调用本地的图片（图库），或者访问其联系人等数据。<br>四个组件正常情况都是在<strong>主线程</strong>运行的，主线程又叫UI线程，顾名思义，用户触摸产生的反馈，绘制的执行都发生在这个线程。</p>
<h2 id="Service执行耗时操作"><a href="#Service执行耗时操作" class="headerlink" title="Service执行耗时操作"></a>Service执行耗时操作</h2><p>Service也是运行在主线程，Service的onStartCommand() 和 onBind() 方法中不能执行耗时操作，IntentService是继承Service的抽象类，在IntentService中有一个工作线程来处理耗时操作。</p>
<h2 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h2><p><strong>standard、singleTop、singTask、singleInstance</strong></p>
<p>（1）standard模式<br>    特点：1.Activity的默认启动模式<br>              2.每启动一个Activity就会在栈顶创建一个新的实例。例如：闹钟程序<br>    缺点：当Activity已经位于栈顶时，而再次启动Activity时还需要在创建一个新的实例，不能直接复用。</p>
<p>（2）singleTop模式<br>    特点：该模式会判断要启动的Activity实例是否位于栈顶，如果位于栈顶直接复用，否则创建新的实例。 例如：浏览器的书签。<br>    缺点：如果Activity并未处于栈顶位置，则可能还会创建多个实例。</p>
<p>（3）singleTask模式<br>    特点：使Activity在整个应用程序中只有一个实例。每次启动Activity时系统首先检查栈中是否存在当前Activity实例，如果存在<br>              则直接复用，并把当前Activity之上所有实例全部出栈。例如：浏览器主界面。</p>
<p>（4）singleInstance模式<br>    特点：该模式的Activity会启动一个新的任务栈来管理Activity实例，并且该实例在整个系统中只有一个。无论从那个任务栈中    启动该Activity，都会是该Activity所在的任务栈转移到前台，从而使Activity显示。主要作用是为了在不同程序中共享一个Activity实例。</p>
<p>总结：Activity 的四种启动模式各有特色，在实际开发中，根据实际情况来选择合适的启动方式即可。</p>
<h2 id="程序中只能唯一一个页面，用哪种启动模式"><a href="#程序中只能唯一一个页面，用哪种启动模式" class="headerlink" title="程序中只能唯一一个页面，用哪种启动模式"></a>程序中只能唯一一个页面，用哪种启动模式</h2><h2 id="Android-的-ANR"><a href="#Android-的-ANR" class="headerlink" title="Android 的 ANR"></a>Android 的 ANR</h2><p>​		ANR，是“Application Not Responding”的缩写，即“应用程序无响应”。如果你应用程序在UI线程被阻塞太长时间，就会出现ANR，通常出现ANR，系统会弹出一个提示提示框，让用户知道，该程序正在被阻塞，是否继续等待还是关闭。</p>
<h2 id="Android-Handle机制"><a href="#Android-Handle机制" class="headerlink" title="Android Handle机制"></a>Android Handle机制</h2><h2 id="子线程里面使用Handler，给主线程发送消息"><a href="#子线程里面使用Handler，给主线程发送消息" class="headerlink" title="子线程里面使用Handler，给主线程发送消息"></a>子线程里面使用Handler，给主线程发送消息</h2><p>一个线程中只能存在一个 Looper，Looper 是保存在 ThreadLocal 中的。主线程（UI 线程）已经创建了一 个 Looper，所以在主线程中不需要再创建 Looper，但是在其他线程中需要创建Looper。每个线程中可以有多个 Handler，即一个 Looper 可以处理来自多个 Handler 的消息。 Looper 中维护一个 MessageQueue，来维护消息队列，消息队列中的 Message 可以来自不同的 Handler。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//主线程 在UI中的oncreate中</span><br><span class="line">  mhandler=new Handler(Looper.getMainLooper())&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                if(msg.what==0)&#123;</span><br><span class="line">                    Log.e(TAG, &quot;主线程收到消息:&quot;+(String) msg.obj );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">//子线程</span><br><span class="line"> class Ctrl extends Thread &#123;</span><br><span class="line"> </span><br><span class="line">        Message msg;</span><br><span class="line">        public  void  run()&#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    msg=new Message();</span><br><span class="line">                    msg.what=0;</span><br><span class="line">                    msg.obj=&quot;hello&quot;;</span><br><span class="line">                    mhandler.sendMessage(msg);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>mhandler.sendMessage(msg);</p>
<h2 id="子线程更新UI方式"><a href="#子线程更新UI方式" class="headerlink" title="子线程更新UI方式"></a>子线程更新UI方式</h2><p>方法一：</p>
<p>主线程中定义Handler</p>
<p>子线程发消息，通知Handler更新UI</p>
<p>方法二：</p>
<p>在子线程中通过**runOnUiThread()**方法更新UI，如果在非上下文类中，通过传递上下文实现调用。</p>
<p>方法三：</p>
<p>AsyncTask</p>
<p>Asynctask是一个抽象类，它是Android封装的一个轻量级异步类（轻量级体现在使用方便，代码简洁）,它可以在线程池中执行后台任务，然后把执行的进度和最终的结果呈现给主线程，并且更新UI。<br> Asynctask内部封装了两个线程池（<code>SerialExecutor</code>和<code>THREAD_POOL_EXECUTOR</code>），和一个<code>Handler（IntentHandler）</code>。</p>
<h2 id="两个Activity之间跳转执行生命周期"><a href="#两个Activity之间跳转执行生命周期" class="headerlink" title="两个Activity之间跳转执行生命周期"></a>两个Activity之间跳转执行生命周期</h2><p>比如说有两个 Activity ，A 和 B，当在 A 里面激活 B 组件的时候, A 会调用 onPause()方法,然后 B 调用 onCreate() 、onStart()、onResume()，此时 B 覆盖了窗体, A 会调用 onStop() 方法，当然如果 B 是个透明的，或者是对话框的样式，就不会调用 A 的 onStop() 方法。<br>此外，倘若 B 已经存在 Activity 栈中，则无需调用 onCreate() 方法。</p>
<h2 id="为什么用Fragment而不是View"><a href="#为什么用Fragment而不是View" class="headerlink" title="为什么用Fragment而不是View"></a>为什么用Fragment而不是View</h2><p>1、Fragment的复用粒度更大。Fragment有<strong>完整的生命周期</strong>，从代码设计角度讲可以提高内聚性，不同情况下还可以设计不同的Fragment，比如<strong>横屏和竖屏</strong>情况下View的显示不一样，那么可以建立2个不同的Fragment去处理，代码上面可以有效的扩展。</p>
<p>从形态上讲和Activity更为接近，当然从编程角度上看也比View更为复杂。但是Fragment可以组装更多的View同一展示，而且生命周期有助于资源的管理。</p>
<p>2、<strong>简单的直接view</strong>，复杂的才用fragment，fragment资源消耗比较大。</p>
<p>3、一个fragment必须总是绑定到一个activity中，虽然fragment有自己的生命周期，但同时也被它的宿主activity的生命周期直接影响。<br>大部分情况下，Fragment用来封转UI的模块化组件；但是也可以创建没有UI的Fragment来提供后台行为，该行为会一直持续到Activity重新启动。这特别适合于定期和UI交互的后台任务或者当因配置改变而导致Activity重新启动是，保存状态变得特别重要的场合。</p>
<h2 id="动态AddView-和使用RecyclerView的区别"><a href="#动态AddView-和使用RecyclerView的区别" class="headerlink" title="动态AddView 和使用RecyclerView的区别"></a>动态AddView 和使用RecyclerView的区别</h2><h2 id="LinkList-与ArrayList"><a href="#LinkList-与ArrayList" class="headerlink" title="LinkList 与ArrayList"></a>LinkList 与ArrayList</h2><p>ArrayList：</p>
<p> ArrayList是基于<strong>动态数组</strong>的数据结构。</p>
<p>因为是数组，所以ArrayList在初始化的时候，有<strong>初始大小10</strong>，插入新元素的时候，会判断是否需要扩容，扩容的步长是<strong>0.5倍原容量</strong>，扩容方式是利用数组的复制，因此有一定的开销；</p>
<p>LinkedList：</p>
<p>内部使用基于链表的数据结构实现存储，LinkedList有一个内部类作为存放元素的单元，里面有三个属性，用来存放元素本身以及前后2个单元的引用，另外LinkedList内部还有一个header属性，用来标识起始位置，LinkedList的第一个单元和最后一个单元都会指向header，因此形成了一个<strong>双向的链表结构。</strong></p>
<h2 id="UDP和TPC的区别，在网络协议哪一层"><a href="#UDP和TPC的区别，在网络协议哪一层" class="headerlink" title="UDP和TPC的区别，在网络协议哪一层"></a>UDP和TPC的区别，在网络协议哪一层</h2><p><em>TCP 和 UDP 是负责提供端到端通信的<strong>传输层协议</strong>。TCP 是面向连接的协议，而 UDP 是无连接协议</em>。</p>
<p><img src="https://garymk-1258635034.cos.ap-beijing.myqcloud.com/typora/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTM4OTg%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70.png" alt="img"></p>
<h2 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的， 所以进程之间要通信必须通过内核。</p>
<p>进程间通信目的一般有共享数据，数据传输，消息通知，进程控制等。以 Unix&#x2F;Linux为例，介绍几种重要的进程间通信方式：<strong>管道、消息队列、****共享内存、信号量、信号、Socket</strong>。</p>
<p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。</p>
<p><strong>跨网络与不同主机上的进程之间通信，就需要Socket通信了</strong>。</p>
<h2 id="Android进程通信"><a href="#Android进程通信" class="headerlink" title="Android进程通信"></a>Android进程通信</h2><p>使用<strong>Bundle</strong></p>
<p>　　我们都知道Android中三大组件Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，所以它可以方便的在不同的进程间进行传输。当我我们在一个进程中启动另外一个进程的Activity、Service、Receiver时，我们就可以在Bundle中附加我们所需要传输给远程进程的信息并通过intent发送出去。这里注意，我们传输的数据必须能够被序列化。</p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快排通过中间取哨兵优化，在i&#x3D;&#x3D;j时停止</p>
<h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><p><strong>1、为什么需要三次握手</strong></p>
<p>目的：为了防止<strong>已失效的连接请求报文段</strong>突然又传送到了服务端，因而产生错误。主要防止资源的浪费。</p>
<p>具体过程：</p>
<p>　　当客户端发出第一个连接请求报文段时并没有丢失，而是在某个网络节点出现了长时间的滞留，以至于延误了连接请求在某个时间之后才到达服务器。这应该是一个早已失效的报文段。但是服务器在收到此失效的连接请求报文段后，以为是客户端的一个新请求，于是就想客户端发出了确认报文段，同意建立连接。假设不采用三次握手，那么只要服务器发出确认后，新的连接就可以建立了。但是由于客户端没有发出建立连接的请求，因此不会管服务器的确认，也不会向服务器发送数据，但服务器却以为新的运输连接已经建立，一直在等待，所以，服务器的资源就白白浪费掉了。</p>
<p><strong>1.1、如果在TCP第三次握手中的报文段丢失了会出现什么情况？</strong></p>
<p>　　客户端会认为此连接已建立，如果客户端向服务器发送数据，服务器将以RST包响应，这样就能感知到服务器的错误了。</p>
<p><strong>2、为什么要四次挥手</strong></p>
<p>　　为了保证在最后断开的时候，<strong>客户端能够发送最后一个ACK报文段能够被服务器接收到</strong>。如果客户端在收到服务器给它的断开连接的请求之后，回应完服务器就直接断开连接的话，若服务器没有收到回应就无法进入CLOSE状态，所以客户端要等待两个最长报文段寿命的时间，以便于服务器没有收到请求之后重新发送请求。</p>
<p>　　防止“已失效的连接请求报文”出现在连接中，在释放连接的过程中会有一些无效的滞留报文，这些报文在经过2MSL的时间内就可以发送到目的地，不会滞留在网络中。<strong>这样就可以避免在下一个连接中出现上一个连接的滞留报文了</strong>。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上,是一种<strong>无状态、无连接</strong>的应用层协议，几年后被HTTP1.1代替并广泛使用</p>
<h3 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h3><ol>
<li>http1.1基于<strong>文本解析</strong>,把所有请求和响应作为纯文本</li>
<li>http1.1加入了<strong>缓存处理（强缓存和协商缓存）</strong></li>
<li>http1.1拥有长连接，并支持请求<strong>管道化</strong>（<code>pipelining</code>），</li>
<li>http1.1流控制基于<strong>tcp连接</strong>。当连接建立时，两端通过系统默认机制建立缓冲区。并通过ack报文来通知对方接收窗口大小，因为http1.1 依靠传输层来避免流溢出，每个tcp连接需要一个独立的流控制机制</li>
</ol>
<p><strong>缓存处理（强缓存和协商缓存）</strong></p>
<p>浏览器缓存能优化性能，而浏览器缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>，都是从客户端读取缓存 <strong>强缓存</strong></p>
<ol>
<li>强缓存不发送请求，直接读取资源，可以获得返回200的状态码</li>
<li>利用http头中的<code>Expires</code>和<code>Cache-Control</code>两个字段来控制，都用来表示资源的缓存时间，Expires能设置失效时间，而Cache-Control能做到更多选项更细致，如果同时设置的话，其优先级<strong>高于</strong>Expires</li>
</ol>
<p><strong>协商缓存</strong></p>
<ol>
<li>通过服务器来确定缓存资源是否可用，通过request header判断是否命中请求，命中后返回304状态码，并返回新的request header通知客户端从缓存里取</li>
<li>普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存</li>
<li>如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，回到1</li>
</ol>
<h3 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h3><ol>
<li>http2相比于http1.1，<strong>性能</strong>大幅度提升</li>
<li>http2通过一个连接来<strong>多路复用</strong></li>
<li>http2拥有<strong>头部压缩</strong></li>
<li>http2拥有<strong>新的二进制格式</strong>，使用二进制框架层把所有消息封装成二进制，且仍然保持http语法</li>
<li>http2允许客户端和服务器端实现他们自己的流控制机制，而不是依赖传输层,两端在传输层交换可用的缓冲区大小，来让他们在多路复用流上设置自己的接收窗口</li>
<li>http2让服务器可以将响应主动“<strong>推送</strong>”到客户端缓存中</li>
</ol>
<h3 id="htpp2头部压缩"><a href="#htpp2头部压缩" class="headerlink" title="htpp2头部压缩"></a>htpp2头部压缩</h3><ol>
<li>http2头部压缩又称为<strong>HAPCK</strong>，<strong>设计简单而灵活</strong>，是因为HPACK格式有意地<code>简单</code>且<code>不灵活</code>能降低由于实现错误而导致的互操作性或安全问题的风险</li>
<li>http1.1没有头部压缩，随着请求增加，冗余头部字段会不必要地占用带宽，从而显着增加延迟，而头部压缩可消除冗余报头字段，限制已知安全攻击的漏洞，并且在受限环境中使用有限的内存要求</li>
</ol>
<h3 id="http2多路复用"><a href="#http2多路复用" class="headerlink" title="http2多路复用"></a>http2多路复用</h3><ol>
<li>http 性能优化的关键并不在于高带宽，而是低延迟</li>
<li>tcp 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度,这种调谐则被称为 tcp 慢启动,由于这种原因，让原本就具有突发性和短时性的 http 连接变的十分低效</li>
<li>http&#x2F;2 通过让所有数据流共用同一个连接，可以更有效地使用 tcp 连接，让高带宽也能真正的服务于 http 的性能提升。而http1.1存在低性能的线头阻塞，一旦有一个请求超时，便会出现阻塞等待的情况</li>
</ol>
<h3 id="http3"><a href="#http3" class="headerlink" title="http3"></a>http3</h3><p>之前说了http2，那么http3就是为了解决http2相关问题而诞生，它基于一个新的传输层协议<strong>QUIC</strong>，而http3就是建立一个在QUIC上运行的HTTP新规范，而http3之前的版本都是基于TCP，QUIC就是为了替代TCP，解决TCP的一些缺陷</p>
<p><strong>tcp</strong></p>
<ol>
<li><strong>不支持流级复用</strong>，TCP会将所有对象序列化在同一个流中，因此，它不知道TCP段的对象级分区，无法在同一个流中复用数据包</li>
<li><strong>会产生冗余通信</strong>，tco三次连接握手会有冗余的消息交换序列</li>
<li><strong>可能会间歇性地挂起数据传输</strong>，tcp中有个因为序列顺序处理丢失的问题的缺陷称为行头阻塞</li>
</ol>
<p><strong>QUIC</strong></p>
<ol>
<li>同样拥有<strong>头部压缩</strong>，并优化了对乱序发送的支持，也优化了压缩率</li>
<li>放弃tcp，通过<strong>udp</strong>建立，提高了连接建立的速度，降低了延迟</li>
<li>tcp本身是无法解决<strong>队头拥塞</strong>，quic则<strong>解决</strong>了这个问题</li>
<li>Connection ID使得http3支持<strong>连接迁移</strong>以及NAT的重绑定</li>
</ol>
<h2 id="非对称加密的过程，公钥私钥"><a href="#非对称加密的过程，公钥私钥" class="headerlink" title="非对称加密的过程，公钥私钥"></a>非对称加密的过程，公钥私钥</h2><p>1、区别：加密一般分为两种，对称加密和非对称加密。对称加密就是加密解密都用同一个秘钥，比如DES、3DES（TripleDES）和AES等。<br>非对称加密就是加密和解密不是用的同一种秘钥，比如RSA算法、DSA算法、ECC算法、DH算法等。<br>在非对称加密中，用来加密的秘钥叫公钥，用来解密的秘钥叫私钥。公钥和私钥都是成对生成的，公钥分发给其他人用来加密，私钥用来解密。<br>2、优缺点：<br>对称加密：解密速度快，但保密性差。<br>非对称加密：加密算法保密性好，它消除了最终用户交换密钥的需要。但是加解密速度要远远低于对称加密。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h2 id="线程如何切换的，谁负责切换"><a href="#线程如何切换的，谁负责切换" class="headerlink" title="线程如何切换的，谁负责切换"></a>线程如何切换的，谁负责切换</h2><p>cpu</p>
<h2 id="CPU-调度算法"><a href="#CPU-调度算法" class="headerlink" title="CPU 调度算法"></a>CPU 调度算法</h2><p>先来先服务调度（First Come First Served，FCFS）</p>
<p>最短作业优先调度（Shortest Job First，SJF）</p>
<p>优先级调度（Highest Privilege First，HPF）</p>
<p>高响应比优先调度（Highest Response Ratio NextHRRN）</p>
<p>轮转法调度（Round Robin，RR）</p>
<p>多级队列调度</p>
<p>多级反馈队列调度</p>
<p><img src="https://garymk-1258635034.cos.ap-beijing.myqcloud.com/typora/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RsOTYyNDU0%2Csize_16%2Ccolor_FFFFFF%2Ct_70.png" alt="img"></p>
<h2 id="锁的概念，乐观锁，悲观锁，关键字"><a href="#锁的概念，乐观锁，悲观锁，关键字" class="headerlink" title="锁的概念，乐观锁，悲观锁，关键字"></a>锁的概念，乐观锁，悲观锁，关键字</h2><p>程序中的锁，则是用来保证我们数据安全的机制和手段</p>
<p><strong>悲观锁</strong><br><strong>悲观锁（Pessimistic Lock）：</strong> 就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放，悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</p>
<p>但是在效率方面，处理加锁的机制会产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，如果已经锁定了一个线程A，其他线程就必须等待该线程A处理完才可以处理</p>
<p>数据库中的行锁，表锁，读锁（共享锁），写锁（排他锁），以及syncronized实现的锁均为悲观锁<br><strong>乐观锁</strong><br><strong>乐观锁（Optimistic Lock）：</strong> 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁，但是如果想要更新数据，则会在更新前检查在读取至更新这段时间别人有没有修改过这个数据。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）,乐观锁适用于多读的应用类型，这样可以提高吞吐量</p>
<h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock 锁"></a>Lock 锁</h2><p>​		在已经有了同步关键字synchronize的的情况下，Java依然在5.0版本中新增了一个同步锁对象lock.又称显示锁，之锁以新增它,是因为synchronize有一些不足，究竟synchronize有哪些不足？在后续课程synchronize与lock的区别，一节中详细介绍，本节主要是来介绍显示锁lock及使用，为什么叫显示锁？是因为我们可以手动的去获取锁与释放锁。之前使用synchronize的的时候，则是自动获取锁与释放锁，锁以synchronize的被称之为隐式锁，lock锁被称之为显示锁。</p>
<h2 id="GC算法，什么时候回收，怎么回收，如何查看对象有没有被引用"><a href="#GC算法，什么时候回收，怎么回收，如何查看对象有没有被引用" class="headerlink" title="GC算法，什么时候回收，怎么回收，如何查看对象有没有被引用"></a>GC算法，什么时候回收，怎么回收，如何查看对象有没有被引用</h2><p>​			 判断对象可被GC回收有两种办法分别是：<strong>引用计数算法</strong>和<strong>根可达性算法</strong>。</p>
<p>​		引用计数算法是一个已经被淘汰的算法，它是给每个对象加一个计数器，当有其他对象引用该对象时，该对象的计数器加一，当这个引用失效时，计数器就会减一，当该对象的计数器为零时，就会认为该对象可以被所回收。</p>
<p>​		引用计数算法是一个简单并且高效的算法，但这种算法却有一个非常大的弊端。就是这种算法会造成对象的循环引用，导致即使这个对象不再被需要，仍然存在一个一直指向它的引用，使得计数器不为零，导致该对象无法被回收，造成内存空间的浪费。</p>
<p>​		根可达性算法是JVM默认的算法，他的原理就是定义一系列的根，我们把这些根称为：GC Roots。从GC Roots开始向下搜索，中间查找的路径被称为：引用链。</p>
<p>​		当一个对象到GC Roots之间没有任何引用链相连接时，我们就认为这个对象可以被GC回收。</p>
<p>根可达性很好的解决了对象循环引用问题。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型：就是指在类定义时不会设置类中的属性或方法参数的具体类型，而是在类使用时（创建对象）再进行类型的定义。会在编译期检查类型是否错误。</p>
<h2 id="堆栈，new是堆还是栈"><a href="#堆栈，new是堆还是栈" class="headerlink" title="堆栈，new是堆还是栈"></a>堆栈，new是堆还是栈</h2><p>栈由系统自动分配内存，用于存放函数参数值和局部变量等。<br>堆由开发人员进行分配和释放，若不释放，程序结束时则&#x2F;由于操作系统自动回收。</p>
<p>基本数据类型共8类，byte、short、int、long、float、double、char、boolean。</p>
<p>—<em>基本类型:变量名和值都放在栈中</em>; —引用类型:变量名(存放内存地址值,指向所引用的对象)放在栈中,该变量所指向的对象放在堆中。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解的英文名叫“Annotation”，是 Java 中给类、方法以及成员变量等元素增加元数据的方式。<strong>换言之注解就是用于描述这些元素的。</strong></p>
<p>Java 的注解可以应用在类、接口、方法、方法的参数、成员变量和方法内的局部变量之上</p>
<p>@Override 注解用于标注方法，它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们在一个没有覆盖父类方法的方法上应用 @Override 注解时，Java编译器会告警。</p>
<h2 id="JVM内存模型，寄存器"><a href="#JVM内存模型，寄存器" class="headerlink" title="JVM内存模型，寄存器"></a>JVM内存模型，寄存器</h2><h2 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Glide.with(this).load(url).into(imageView);</span><br></pre></td></tr></table></figure>

<p>Glide的缓存分为两个模块，一个是内存缓存，一个是硬盘缓存。</p>
<p>内存缓存的作用是防止应用重复将图片数据读取到内存当中；</p>
<p>硬盘缓存的作用是防止应用重复从网络或其他地方下载和读取数据。</p>
<h2 id="OKhttp"><a href="#OKhttp" class="headerlink" title="OKhttp"></a>OKhttp</h2><h3 id="1、拿到OkHttpClient对象"><a href="#1、拿到OkHttpClient对象" class="headerlink" title="1、拿到OkHttpClient对象"></a>1、拿到OkHttpClient对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">okhttpclient client=new OKhttpclient（）；</span><br></pre></td></tr></table></figure>

<h3 id="2-构造Request对象"><a href="#2-构造Request对象" class="headerlink" title="2 . 构造Request对象"></a>2 . 构造Request对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request request = new Request.Builder()</span><br><span class="line">                .get()</span><br><span class="line">                .url(&quot;https:www.baidu.com&quot;)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>

<h3 id="3、将Request封装为Call"><a href="#3、将Request封装为Call" class="headerlink" title="3、将Request封装为Call"></a>3、将Request封装为Call</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Call call = client.newCall(request);</span><br></pre></td></tr></table></figure>

<h3 id="4-根据需要调用同步或者异步请求方法"><a href="#4-根据需要调用同步或者异步请求方法" class="headerlink" title="4 . 根据需要调用同步或者异步请求方法"></a>4 . 根据需要调用同步或者异步请求方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//同步调用,返回Response,会抛出IO异常</span><br><span class="line">Response response = call.execute();</span><br><span class="line"></span><br><span class="line">//异步调用,并设置回调函数</span><br><span class="line">call.enqueue(new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">        Toast.makeText(OkHttpActivity.this, &quot;get failed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(Call call, final Response response) throws IOException &#123;</span><br><span class="line">        final String res = response.body().string();</span><br><span class="line">        runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                contentTv.setText(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>因为TCP协议只能发送字节流，因此需要将数据序列化。protobuf序列化和反序列化的时间开销都很少。因为<strong>序列化后的数据都是以二进制数据存储</strong>，因此空间开销也少很多。</p>
<p>ProtoBuf是跨语言的，使用ProtoBuf的第一步是先定一个<strong>proto 文件</strong>，使用生成器产生不同语音的代码。</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status  查看当前状态</span><br><span class="line">git log  查看提交日志</span><br><span class="line">git merge dev  合并dev分支至当前分支</span><br><span class="line">git add .      添加当前目录全部文件至暂存区</span><br><span class="line">git commit -m &#x27;测试&#x27;     提交，提交信息为测试</span><br><span class="line">git push origin master  推送至远端分支（master为需要推送分支，按实际需要选择）</span><br><span class="line">git pull origin master  合并远端分支至本地 (git pull 等于 git fetch + git merge)</span><br><span class="line">git pull --rebase origin master rebase方式合并远端分支至本地</span><br><span class="line">git branch 查看当前分支</span><br><span class="line">git branch dev 创建dev分支  （dev可选）</span><br><span class="line">git branch -d dev 删除dev分支</span><br><span class="line">git branch -r 查看远程分支</span><br><span class="line">git branch -a 查看所有分支 （包括远程分支）</span><br><span class="line">git checkout master 切换至master分支</span><br><span class="line">git checkout -b dev 创建dev分支并切换至dev分支</span><br><span class="line">git checkout -b dev origin/dev 创建远程分支到本地</span><br><span class="line">git restore file 丢弃工作区修改（file为具体文件名称）</span><br><span class="line">git restore * 丢弃所有工作区修改</span><br><span class="line">git restore --staged file  回退暂存区文件 不会更改文件内容</span><br><span class="line">git rebase --continue   rebase后继续操作</span><br><span class="line">git rebase --abort 退出rebase 操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="图片加载过程"><a href="#图片加载过程" class="headerlink" title="图片加载过程"></a>图片加载过程</h2><p><img src="https://garymk-1258635034.cos.ap-beijing.myqcloud.com/typora/d66350ccda3766cc89bd9f70538a7e0f.jpeg" alt="img"></p>
<p>第一步，资源匹配：</p>
<p>计算设备<strong>dpi</strong>，然后去dpi匹配的drawable文件夹查找图片，如果合适不缩放图片直接显示，如果不合适对图片进行缩放。</p>
<p>第二部，解码资源：</p>
<p>对图片资源进行解码，并获得图片资源Bitmap。</p>
<p>BitmapFactory.doDecode()进行解码；</p>
<p>先采样再缩放，输出Bitmap。</p>
<h2 id="setImageResource和setImageBitmap"><a href="#setImageResource和setImageBitmap" class="headerlink" title="setImageResource和setImageBitmap"></a>setImageResource和setImageBitmap</h2><p>第一种setImageResource 是从资源drawable中通过资源id找到文件转成可绘制对象drawable 然后绘制。这个方法会自动适配分辨率。适用于不频繁设置图片图片资源不会太大的情况。 但是</p>
<p>对于大图片时或者你需要不断的重复的设置图片 调用这个方法生成的drawable里一样会生成一个bitmap对象 因为bitmap是通过bitmapfactory生成的 有一部分要调用C库所以需要开辟一部分</p>
<p>native本地内存空间以及一部分jvm的内存空间。而native本地内存空间是C开辟的 jvm的gc垃圾回收器是回收不了这部分空间的，这个时候如果你频繁的调用setImageResource且没有手动调</p>
<p>recycle native的内存空间很难被释放掉。jvm的内存也不会及时得到回收这样就相当容易导致内存溢出。</p>
<hr>
<p>而setImageBitmap 当你需要频繁设置大图片时 通过bitmapfactory生成bitmap然后设置 然后每次设置前将之前的bitmap手动掉recycle 置为可回收状态 这样很大程度能防止内存泄露溢出</p>
<p>所以看你的需求 你的图片是不频繁设置且不会太大就用第一种 如果需求不断的重复更新设置那最好用第二个并且记住手动及时回收后再设置 如果有用到图片缓存的话则不要将大图片列入缓存</p>
<p>中 图片的缓存模块最好只存储小且利用频繁的图片以节省内存和时间开销 大图则需做手动回收 以保证低端点的机子不会oom</p>
<p>但通过查阅资料学习，我发现像setImageResource这些函数在完成decode后最终都是通过Java层的<strong>Createbitmap</strong>来完成，需要消耗更多内存。最优的降低内存的方式，是通过使用BitmapFactory.decodeStream()方法来创建一个bitmap，再将其设置为Imageview 的source，优化的原理在于BitmapFactory是通过JNI调用底层C&#x2F;C++实现的驱动完成了decode，从而节省了java空间。</p>
<p>但是随着Android的变迁Bitmap的回收机制也是在变化。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://garymk.cn">Gary MK</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://garymk.cn/2023/02/20/2023%E9%9D%A2%E7%BB%8F/">https://garymk.cn/2023/02/20/2023面经/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://garymk.cn" target="_blank">GaryMK</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/23/QT%E5%BC%80%E5%8F%91%E8%AF%AD%E6%B3%95%E6%97%A0%E8%AF%AF%E4%BE%9D%E7%84%B6%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" title="Qt开发语法无误依然报错问题汇总"><img class="cover" src="https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Qt开发语法无误依然报错问题汇总</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/09/SCI-Collections/" title="SCI Collections"><img class="cover" src="https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SCI Collections</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wx.qlogo.cn/mmhead/Q3auHgzwzM40NV46MrdfnryFg6EIMAlt8uO7tfbtbs6XH9W2Z1Opfw/0" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Gary MK</div><div class="author-info__description">程序开发与算法研究</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/GaryMK"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/img/weixin.png" target="_blank" title="WeChat"><i class="fa-brands fa-weixin" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://github.com/garymk" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:chenxingmk@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa-solid fa-rss" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2023%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F"><span class="toc-number">1.</span> <span class="toc-text">2023校招面经</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RecycleView-%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">RecycleView  实现列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RecycleView-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%9D%A1%E7%9B%AE"><span class="toc-number">1.2.</span> <span class="toc-text">RecycleView 实现多条目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%EF%BC%8CHashSet-%E5%92%8C-HashTable"><span class="toc-number">1.3.</span> <span class="toc-text">HashMap，HashSet 和 HashTable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E7%9A%84%E5%88%9D%E5%A7%8BSize"><span class="toc-number">1.4.</span> <span class="toc-text">Hash的初始Size</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.5.</span> <span class="toc-text">哈希冲突</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E6%B3%84%E6%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">Synchronized实现原理，泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%B3%84%E6%BC%8F-Lock-Leak%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">锁泄漏(Lock Leak）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">2.2.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E6%88%90"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">构成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%88%90%E4%B8%BA%E5%9E%83%E5%9C%BE%E7%9A%84%E5%88%A4%E6%96%AD%E4%BE%9D%E6%8D%AE"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">对象成为垃圾的判断依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">垃圾回收算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.3.</span> <span class="toc-text">Android计算图片大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84%E5%8F%8D%E5%B0%84"><span class="toc-number">2.4.</span> <span class="toc-text">Java的反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.1.</span> <span class="toc-text">获取类对应的字节码的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%8D%95%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">手写单例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%98%AF%E8%BF%90%E8%A1%8C%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">四大组件是运行在主线程还是子线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.</span> <span class="toc-text">Service执行耗时操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.8.</span> <span class="toc-text">Activity启动模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8F%AA%E8%83%BD%E5%94%AF%E4%B8%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E7%94%A8%E5%93%AA%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.9.</span> <span class="toc-text">程序中只能唯一一个页面，用哪种启动模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-%E7%9A%84-ANR"><span class="toc-number">2.10.</span> <span class="toc-text">Android 的 ANR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-Handle%E6%9C%BA%E5%88%B6"><span class="toc-number">2.11.</span> <span class="toc-text">Android Handle机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8Handler%EF%BC%8C%E7%BB%99%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">2.12.</span> <span class="toc-text">子线程里面使用Handler，给主线程发送消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0UI%E6%96%B9%E5%BC%8F"><span class="toc-number">2.13.</span> <span class="toc-text">子线程更新UI方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAActivity%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC%E6%89%A7%E8%A1%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.14.</span> <span class="toc-text">两个Activity之间跳转执行生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Fragment%E8%80%8C%E4%B8%8D%E6%98%AFView"><span class="toc-number">2.15.</span> <span class="toc-text">为什么用Fragment而不是View</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81AddView-%E5%92%8C%E4%BD%BF%E7%94%A8RecyclerView%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.16.</span> <span class="toc-text">动态AddView 和使用RecyclerView的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkList-%E4%B8%8EArrayList"><span class="toc-number">2.17.</span> <span class="toc-text">LinkList 与ArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E5%92%8CTPC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%93%AA%E4%B8%80%E5%B1%82"><span class="toc-number">2.18.</span> <span class="toc-text">UDP和TPC的区别，在网络协议哪一层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.19.</span> <span class="toc-text">进程通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.20.</span> <span class="toc-text">Android进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92"><span class="toc-number">2.21.</span> <span class="toc-text">快排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.22.</span> <span class="toc-text">三次握手与四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">2.23.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http1-0"><span class="toc-number">2.23.1.</span> <span class="toc-text">http1.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http1-1"><span class="toc-number">2.23.2.</span> <span class="toc-text">http1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http2"><span class="toc-number">2.23.3.</span> <span class="toc-text">http2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#htpp2%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.23.4.</span> <span class="toc-text">htpp2头部压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">2.23.5.</span> <span class="toc-text">http2多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http3"><span class="toc-number">2.23.6.</span> <span class="toc-text">http3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5"><span class="toc-number">2.24.</span> <span class="toc-text">非对称加密的过程，公钥私钥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.25.</span> <span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%8C%E8%B0%81%E8%B4%9F%E8%B4%A3%E5%88%87%E6%8D%A2"><span class="toc-number">2.26.</span> <span class="toc-text">线程如何切换的，谁负责切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.27.</span> <span class="toc-text">CPU 调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%8C%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.28.</span> <span class="toc-text">锁的概念，乐观锁，悲观锁，关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock-%E9%94%81"><span class="toc-number">2.29.</span> <span class="toc-text">Lock 锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E7%AE%97%E6%B3%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6%EF%BC%8C%E6%80%8E%E4%B9%88%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E6%9C%89%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%BC%95%E7%94%A8"><span class="toc-number">2.30.</span> <span class="toc-text">GC算法，什么时候回收，怎么回收，如何查看对象有没有被引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.31.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%EF%BC%8Cnew%E6%98%AF%E5%A0%86%E8%BF%98%E6%98%AF%E6%A0%88"><span class="toc-number">2.32.</span> <span class="toc-text">堆栈，new是堆还是栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.33.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.34.</span> <span class="toc-text">JVM内存模型，寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Glide"><span class="toc-number">2.35.</span> <span class="toc-text">Glide</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OKhttp"><span class="toc-number">2.36.</span> <span class="toc-text">OKhttp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8B%BF%E5%88%B0OkHttpClient%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.36.1.</span> <span class="toc-text">1、拿到OkHttpClient对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0Request%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.36.2.</span> <span class="toc-text">2 . 构造Request对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%B0%86Request%E5%B0%81%E8%A3%85%E4%B8%BACall"><span class="toc-number">2.36.3.</span> <span class="toc-text">3、将Request封装为Call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%B9%E6%8D%AE%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8%E5%90%8C%E6%AD%A5%E6%88%96%E8%80%85%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.36.4.</span> <span class="toc-text">4 . 根据需要调用同步或者异步请求方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Protobuf"><span class="toc-number">2.37.</span> <span class="toc-text">Protobuf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git"><span class="toc-number">2.38.</span> <span class="toc-text">Git</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.39.</span> <span class="toc-text">图片加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setImageResource%E5%92%8CsetImageBitmap"><span class="toc-number">2.40.</span> <span class="toc-text">setImageResource和setImageBitmap</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/13/ProjectA/" title="ProjectA">ProjectA</a><time datetime="2023-12-13T09:29:11.000Z" title="发表于 2023-12-13 17:29:11">2023-12-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/13/MAC%E8%AE%BE%E7%BD%AE%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/" title="MAC设置显示隐藏文件">MAC设置显示隐藏文件</a><time datetime="2023-12-13T06:49:03.000Z" title="发表于 2023-12-13 14:49:03">2023-12-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/11/RN%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="RN环境配置">RN环境配置</a><time datetime="2023-12-11T13:49:48.000Z" title="发表于 2023-12-11 21:49:48">2023-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/11/zsh%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/" title="zsh安装及配置">zsh安装及配置</a><time datetime="2023-12-11T13:24:32.000Z" title="发表于 2023-12-11 21:24:32">2023-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/29/Mac%E7%B3%BB%E7%BB%9FPython%E6%8A%A5%E9%94%99/" title="Mac系统Python报错">Mac系统Python报错</a><time datetime="2023-08-29T11:58:44.000Z" title="发表于 2023-08-29 19:58:44">2023-08-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Gary MK</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://garymk.github.io/GaryMK.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline.garymk.cn',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline.garymk.cn/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-5G6KHDXYS9', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>